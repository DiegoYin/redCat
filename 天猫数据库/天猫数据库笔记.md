##### 数据库的三范式与反三范式

 数据库的三范式指的是数据库创建的原则(第二范式依赖于第一范式,第三范式依赖于第二范式)

1. 第一范式(1NF): 数据库表的每一列都是不可分割的原子项,字段不可是集合等.

2. 第二范式(2NF): 每个表必须有且仅有一个数据元素为主键,其他属性依赖于主键

3. 第三范式(3NF): 数据表中的每一列都和主键直接相关,而不能间接相关



    数据库三范式还有一个反范式化,反范式化是为了通过增加冗余或者重复的数据来提高数据库的可读性,目的是减少关联查询(join).

    故名思义，跟范式所要求的正好相反，在反范式的设计模式，我们可以允许适当的数据的冗余，用这个冗余去取操作数据时间的缩短。**也就是利用空间来换取时间**,把数据冗余在多个表中，当查询时可以减少或者是避免表之间的关联.

```
如我们现在要对一个 学校的课程表进行操作，现在有两张表，一张是学生信息student（a_id,a_name,a_adress,b_id）表，一张是课程表 subject(b_id,b_subject)，现在我们需要一个这样的信息，把选择每个课程的的课程名称和学生姓名输出来：

  SQL语句为：select  B.b_id,B.b_subject,A_a_name from student A ,subject B;

   当上面的数据量不多时，我们这样去查询没有问题；当我们的两张表的数据都是在百万级的时候，我们去查上面的信息， 问题出现了，这个查询动不动就是几百毫秒，甚至更慢，这样的查询效率根本不能满足我们对于网页速度的要求（一般不能超过100毫秒），怎么办？当然要反范式，在课程表里面添加冗余字段——学生姓名，这样我们就可以通过下面的查询达到同样的目的：

SQL语句为：select  b_id,b_subject,a_name from subject B;

将两个查询放在一起查看执行计划，就会发现，第一个查询开销占了92%，而第二个才8%，也就是说，第二个查询比起第一个查询，效率上优化了10倍以上，成果显著啊。
```



##### 数据库约束

数据库约束分为五大类(关键字):

1. 主键约束,唯一性非空性
   
   主键约束添加的3种办法:
   
   1. 直接在字段后面添加:primary key
   
   2. 在最后给指定列添加:
      
      primary key(name)
   
   3. 外部操作
      
      ```sql
      alter table user drop primary key;-- 删除主键约束
      
      alter table user add primary key(id,name); -- 添加主键约束
      
      alter table user modify id int primary key；-- 修改主键约束
      ```

2. 外键约束,order表中含有user表的主键,order表就拥有user表的外键约束
   
   外键约束添加的3种办法:
   
   1. 直接在字段后面添加: references t_user(uid)
   
   2. 在最后给指定列添加: 
      
      constraint 约束名 foreign key(Uid) references 从表名(UserId)
   
   3. 外部操作
      
      ```sql
      alter table student drop foreign key student_id; -- 删除外键约束
      alter table student add foreign key(classes_name,classes_number) references classes(name, number);-- 增加外键约束
      ```
      
      

3. 唯一约束,指的是类似身份证这种,每人只有一个,为唯一约束,可以为空,不可以重复
   
   唯一约束的3种添加方法:
   
   1. 直接在字段后面添加 unique
   
   2. 在最后指定哪些字段为unique(```)
   
   3. 外部操作
      
      ```sql
      alter table user add unique (name, password);-- 添加唯一约束
      
      alter table user modify name varchar(25) unique;--修改唯一约束
      
      alter table user drop index name;-- 删除约束
      ```

4. not null 非空约束,非空约束用于确保当前咧的值补位空值,非空约束只能出现在表对象的列上.
   
   非空约束的添加方法:
   
   1. 直接在字段后面添加: not null
   
   2. 外部操作
      
      ```sql
      alter table user

      modify sex varchar(2) not null;-- 增加非空约束
      

      alter table user modify sex varchar(2) null;-- 取消非空约束
      

      alter table user modify sex varchar(2) default 'abc' null;
      -- 取消非空约束，增加默认值
      ```

5. auto_increment 自增约束.直接在字段最后添加.

6. default 默认约束,如果不给该列值的话,他会有一个默认值.直接在字段最后添加.



##### 数据库表关系设定

数据库表关系设定,在特定的情况下使用一对一,一对多,多对多

```
1、一对一 可以两个实体设计在一个数据库中 例如设计一个夫妻表，里面放丈夫和妻子(丈夫与妻子一对一)

2、一对多可以建两张表，将一这一方的主键作为多那一方的外键，例如一个4102学生表可以加1653一个字段指向班级(班级与学生一对多的关系)
3、多对多可以多加一张中间表，将另外内两个表的主键放到这个表中（如教师和学生就是多对多的容关系）
```



##### 数据库事务的四大特性

1. 什么是数据库事务?
   
   数据库管理系统执行过程中的一个逻辑单位,由一个有限的数据库操作序列构成,意思是一连串的数据库操作,即一串增删查改的集合.

2. 数据库事务做了什么?
   
   把事务的状态从一个状态转换到另一个状态.一个点到另一个点,就是事务



数据库事务的四大特性:

1. 第一个特性,原子性(Atomcity)
   
   假如有个方法对一个属性进行了N次更新,执行到一半,有一个语句出现了异常,使得我们操作后的点与我们预先的点不同,所以原子性要求你这个方法全部执行,要么就不执行

2. 第二个特性 一致性(Consistency)
   
   原子性中规定方法中的操作都执行或者都不执行,但并没有说要所有的操作一起执行,所以操作的执行也是有先后顺序的,那我们要是在执行一半时查询了数据库,那我们会得到中间的更新属性?答案是不会的,一致性规定事务前后只存在两个状态,提交前和提交后,所以中间查询是不会查询出第三个状态的.

3. 第三个特性 隔离性(lsolation)
   
   事务的隔离性基于原子性,和一致性,每一个事务可以并发执行,但是互不干扰,也有可能不同的事务操作同一个资源,这个时候为了保持隔离性会用到锁方案.

4. 第四个特性 持久性(Durability)
   
   当一个事务提交了之后那这个数据库的状态就发生了改变,哪怕提交后刚写入一半数据到数据库,数据库宕机了,那么事务也会在下次重启开机后,根据提交的日志进行回滚,然后再继续事务,最终完成提交的事务.

##### 不考虑事务,隔离级别

###### 1，脏读

　　脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

###### 2，不可重复读

　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

###### 3，虚读(幻读)

　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。




























